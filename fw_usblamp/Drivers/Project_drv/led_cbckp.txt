/*
 * led.c - SK6812 RGBW (GRBW) on STM32U0
 * LPTIM2 PWM @800kHz + DMA NORMAL (non-circular)
 * DMA requests generated by DMAMUX Request Generator (trigger = LPTIM2_OUT)
 *
 * Works around STM32U0 LPTIM UE-DMA behavior (only one request if UE flag not cleared by ARR write).
 */

#include "led.h"
#include "main.h"
#include <string.h>
#include <stdio.h>

extern LPTIM_HandleTypeDef hlptim2;
extern DMA_HandleTypeDef   hdma_lptim2_ic1;   // keep your handle name

// ===================== LED params =====================
#define LED_COUNT           30u
#define BYTES_PER_LED       4u
#define DATA_SLOTS          (LED_COUNT * BYTES_PER_LED * 8u)   // 960

// ===================== Timing =====================
// Assumes LPTIM kernel clk ~16 MHz: ARR=19 => 800kHz
#define LED_ARR             19u
#define T0H_TICKS            5u
#define T1H_TICKS           10u

// Reset time: we enforce >=1ms between renders by timestamp (timer stopped => line low)
#define RESET_GAP_MS         1u

// ===================== Buffers / state =====================
static uint8_t  s_fb[LED_COUNT][BYTES_PER_LED];   // GRBW
static uint16_t s_cmp[DATA_SLOTS];                // duty per bit (halfword is enough)

static volatile uint8_t  s_busy = 0;
static volatile uint32_t s_done = 0;
static volatile uint32_t s_err  = 0;

static uint32_t s_last_stop_ms = 0;

// ===================== Low-level LPTIM =====================
static void lptim2_stop_raw(void)
{
  __HAL_LPTIM_DISABLE(&hlptim2);
}

static void lptim2_start_raw(void)
{
  __HAL_LPTIM_DISABLE(&hlptim2);
  hlptim2.Instance->ICR = 0xFFFFFFFFu;

  // PWM waveform mode, active high, preload enabled
  SET_BIT(hlptim2.Instance->CFGR, LPTIM_CFGR_WAVE);
  CLEAR_BIT(hlptim2.Instance->CFGR, LPTIM_CFGR_WAVPOL);
  SET_BIT(hlptim2.Instance->CFGR, LPTIM_CFGR_PRELOAD);

  __HAL_LPTIM_ENABLE(&hlptim2);

  // continuous start
  SET_BIT(hlptim2.Instance->CR, LPTIM_CR_CNTSTRT);
}

static void led_force_low_and_stop(void)
{
  // stop DMA, disable generator, stop timer, force low
#if defined(HAL_DMA_EX_MODULE_ENABLED)
  (void)HAL_DMAEx_DisableMuxRequestGenerator(&hdma_lptim2_ic1);
#endif
  (void)HAL_DMA_Abort(&hdma_lptim2_ic1);

  hlptim2.Instance->CCR1 = 0u;
  lptim2_stop_raw();

  s_busy = 0;
  s_last_stop_ms = HAL_GetTick();
}

// ===================== DMAMUX request generator =====================
static HAL_StatusTypeDef reqgen_enable_lptim2_out(void)
{
#if !defined(HAL_DMA_EX_MODULE_ENABLED)
  return HAL_ERROR;
#else
  HAL_DMA_MuxRequestGeneratorConfigTypeDef cfg;

  // Different Cube/HAL versions name this slightly differently.
#if defined(HAL_DMAMUX1_REQ_GEN_LPTIM2_OUT)
  cfg.SignalID = HAL_DMAMUX1_REQ_GEN_LPTIM2_OUT;
#elif defined(HAL_DMAMUX_REQ_GEN_LPTIM2_OUT)
  cfg.SignalID = HAL_DMAMUX_REQ_GEN_LPTIM2_OUT;
#else
# error "Missing DMAMUX request-generator signal for LPTIM2_OUT in stm32u0xx_hal_dma_ex.h"
#endif

#if defined(HAL_DMAMUX_REQ_GEN_RISING)
  cfg.Polarity = HAL_DMAMUX_REQ_GEN_RISING;
#else
# error "Missing HAL_DMAMUX_REQ_GEN_RISING"
#endif

  cfg.RequestNumber = 1;

  (void)HAL_DMAEx_DisableMuxRequestGenerator(&hdma_lptim2_ic1);
  if (HAL_DMAEx_ConfigMuxRequestGenerator(&hdma_lptim2_ic1, &cfg) != HAL_OK)
    return HAL_ERROR;
  if (HAL_DMAEx_EnableMuxRequestGenerator(&hdma_lptim2_ic1) != HAL_OK)
    return HAL_ERROR;

  return HAL_OK;
#endif
}

// ===================== Helpers =====================
static void led_build_cmp(void)
{
  uint32_t p = 0;

  for (uint32_t i = 0; i < LED_COUNT; i++)
  {
    for (uint32_t b = 0; b < BYTES_PER_LED; b++)
    {
      uint8_t v = s_fb[i][b]; // GRBW
      for (int bit = 7; bit >= 0; bit--)
      {
        s_cmp[p++] = (v & (1u << bit)) ? (uint16_t)T1H_TICKS : (uint16_t)T0H_TICKS;
      }
    }
  }
}

// Wait for N counter wraps (each wrap = one PWM period).
// We use this in DMA complete callback to let the last preloaded CCR take effect.
static void wait_wraps(uint32_t wraps)
{
  uint16_t prev = (uint16_t)(hlptim2.Instance->CNT & 0xFFFFu);
  uint32_t w = 0;
  while (w < wraps)
  {
    uint16_t now = (uint16_t)(hlptim2.Instance->CNT & 0xFFFFu);
    if (now < prev) w++;
    prev = now;
  }
}

// ===================== DMA callbacks =====================
static void led_dma_cplt(DMA_HandleTypeDef *hdma)
{
  (void)hdma;

  // Disable generator so no further requests happen
#if defined(HAL_DMA_EX_MODULE_ENABLED)
  (void)HAL_DMAEx_DisableMuxRequestGenerator(&hdma_lptim2_ic1);
#endif

  // IMPORTANT:
  // With PRELOAD enabled, the last CCR written by DMA is applied on the *next* update.
  // So after DMA finishes writing the last bit duty, we must allow ~2 periods:
  // - finish current period, then one more period with last duty applied.
  wait_wraps(2);

  led_force_low_and_stop();
  s_done++;
}

static void led_dma_err_cb(DMA_HandleTypeDef *hdma)
{
  (void)hdma;
  led_force_low_and_stop();
  s_err++;
}

// ===================== API =====================
void led_init(void)
{
  HAL_GPIO_WritePin(CTL_LEN_GPIO_Port, CTL_LEN_Pin, GPIO_PIN_SET);
  HAL_Delay(50);

  memset(s_fb, 0, sizeof(s_fb));
  s_busy = 0;
  s_done = 0;
  s_err  = 0;
  s_last_stop_ms = 0;

  hdma_lptim2_ic1.XferCpltCallback  = led_dma_cplt;
  hdma_lptim2_ic1.XferErrorCallback = led_dma_err_cb;

  led_force_low_and_stop();
}

void led_deinit(void)
{
  led_force_low_and_stop();
  HAL_GPIO_WritePin(CTL_LEN_GPIO_Port, CTL_LEN_Pin, GPIO_PIN_RESET);
}

void led_get_status(char *buf, size_t len)
{
  uint32_t ndtr = __HAL_DMA_GET_COUNTER(&hdma_lptim2_ic1);
  uint32_t cnt  = (uint32_t)(hlptim2.Instance->CNT & 0xFFFFu);
  uint32_t arr  = (uint32_t)(hlptim2.Instance->ARR & 0xFFFFu);
  uint32_t ccr1 = (uint32_t)(hlptim2.Instance->CCR1 & 0xFFFFu);
  uint32_t en   = (hlptim2.Instance->CR & LPTIM_CR_ENABLE) ? 1u : 0u;

  snprintf(buf, len,
    "VER=REQGEN pwr=1 busy=%lu dma_state=%d ndtr=%lu req=%lu lptim_en=%lu cnt=%lu arr=%lu ccr1=%lu done=%lu err=%lu",
    (unsigned long)s_busy,
    (int)hdma_lptim2_ic1.State,
    (unsigned long)ndtr,
    (unsigned long)hdma_lptim2_ic1.Init.Request,
    (unsigned long)en,
    (unsigned long)cnt,
    (unsigned long)arr,
    (unsigned long)ccr1,
    (unsigned long)s_done,
    (unsigned long)s_err
  );
}

void led_set_RGB(uint8_t index, uint8_t r, uint8_t g, uint8_t b)
{
  if (index >= LED_COUNT) return;
  s_fb[index][0] = g;
  s_fb[index][1] = r;
  s_fb[index][2] = b;
  s_fb[index][3] = 0;
}

void led_set_RGBW(uint8_t index, uint8_t r, uint8_t g, uint8_t b, uint8_t w)
{
  if (index >= LED_COUNT) return;
  s_fb[index][0] = g;
  s_fb[index][1] = r;
  s_fb[index][2] = b;
  s_fb[index][3] = w;
}

void led_set_all_RGB(uint8_t r, uint8_t g, uint8_t b)
{
  for (uint32_t i = 0; i < LED_COUNT; i++)
  {
    s_fb[i][0] = g;
    s_fb[i][1] = r;
    s_fb[i][2] = b;
    s_fb[i][3] = 0;
  }
}

void led_set_all_RGBW(uint8_t r, uint8_t g, uint8_t b, uint8_t w)
{
  for (uint32_t i = 0; i < LED_COUNT; i++)
  {
    s_fb[i][0] = g;
    s_fb[i][1] = r;
    s_fb[i][2] = b;
    s_fb[i][3] = w;
  }
}

void led_render(void)
{
  if (s_busy) { s_err++; return; }

  // enforce reset low gap
  if ((HAL_GetTick() - s_last_stop_ms) < RESET_GAP_MS)
    return;

  led_build_cmp();
  led_force_low_and_stop();

  // DMA uses Request Generator 0
#if !defined(DMA_REQUEST_GENERATOR0)
# error "Missing DMA_REQUEST_GENERATOR0"
#endif
  hdma_lptim2_ic1.Init.Request             = DMA_REQUEST_GENERATOR0;
  hdma_lptim2_ic1.Init.Direction           = DMA_MEMORY_TO_PERIPH;
  hdma_lptim2_ic1.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_lptim2_ic1.Init.MemInc              = DMA_MINC_ENABLE;
  hdma_lptim2_ic1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
  hdma_lptim2_ic1.Init.MemDataAlignment    = DMA_MDATAALIGN_HALFWORD;
  hdma_lptim2_ic1.Init.Mode                = DMA_NORMAL;
  hdma_lptim2_ic1.Init.Priority            = DMA_PRIORITY_HIGH;

  (void)HAL_DMA_DeInit(&hdma_lptim2_ic1);
  if (HAL_DMA_Init(&hdma_lptim2_ic1) != HAL_OK) { s_err++; return; }

  hdma_lptim2_ic1.XferCpltCallback  = led_dma_cplt;
  hdma_lptim2_ic1.XferErrorCallback = led_dma_err_cb;

  // LPTIM base
  __HAL_LPTIM_DISABLE(&hlptim2);
  hlptim2.Instance->ARR  = LED_ARR;
  hlptim2.Instance->RCR  = 0u;
  hlptim2.Instance->CCR1 = (uint32_t)s_cmp[0];   // first bit duty
  __HAL_LPTIM_ENABLE(&hlptim2);

  // Configure & enable request generator on LPTIM2_OUT edges
  if (reqgen_enable_lptim2_out() != HAL_OK) { s_err++; led_force_low_and_stop(); return; }

  // Start DMA for remaining 959 values -> CCR1
  if (HAL_DMA_Start_IT(&hdma_lptim2_ic1,
      (uint32_t)(uintptr_t)&s_cmp[1],
      (uint32_t)(uintptr_t)&hlptim2.Instance->CCR1,
      (uint32_t)(DATA_SLOTS - 1u)) != HAL_OK)
  {
    s_err++;
    led_force_low_and_stop();
    return;
  }

  // Start PWM timebase
  lptim2_start_raw();

  s_busy = 1;
}

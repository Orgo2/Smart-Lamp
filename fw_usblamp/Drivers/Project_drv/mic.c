/*
 * mic.c - PDM microphone capture over SPI1 + DMA.
 * Provides a lightweight RMS/dBFS estimate over 50 ms windows (for simple VU-meter effects).
 */

#include "main.h"
#include "mic.h"
#include "stm32u0xx_hal.h"

#include <stdint.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>

/* SPI1 handle is generated by CubeMX in main.c. */
extern SPI_HandleTypeDef hspi1;
extern RTC_HandleTypeDef hrtc;

/* DSP config: decimation + 50 ms windows for RMS/dBFS measurement. */
/* DMA strategy:
 *  - Normal DMA: start -> wait -> process -> restart (small gaps between blocks).
 *  - Circular DMA (CubeMX): continuous clock, process half/full buffers without restart.
 */

/* DMA RX buffer for one block. */
static uint16_t s_rx_buf[MIC_DMA_WORDS];

/* DMA transfer state. */
static volatile uint8_t s_spi_done;
static volatile uint8_t s_spi_half;
static volatile uint8_t s_spi_err;
static uint32_t s_dma_t0_ms;
static uint32_t s_dma_last_evt_ms;
static uint8_t  s_dma_circular;
static uint32_t s_capture_t0_ms;

/* Diagnostics (no-scope). */
static volatile uint32_t s_cb_half_count;
static volatile uint32_t s_cb_full_count;
static volatile uint32_t s_cb_err_count;
static volatile uint32_t s_cb_half_last_ms;
static volatile uint32_t s_cb_full_last_ms;
static volatile uint32_t s_cb_err_last_ms;
static uint32_t s_cb_start_ms;
static uint32_t s_cb_full_start_count;

/* Driver state. */
static uint8_t s_inited;
static uint8_t s_running;
static uint8_t s_debug;
static mic_err_t s_last_err;
static const char *s_last_err_msg;

/* Last computed window result. */
static float s_last_dbfs = -1.0f;
static float s_last_rms  = 0.0f;
static uint32_t s_last_seq = 0u;

/* Runtime calibration (defaults from mic.h macros, may be overridden via MIC_CalLoad()). */
static float s_cal_rms_gain      = (float)MIC_CAL_RMS_GAIN;
static float s_cal_db_offset_db  = (float)MIC_CAL_DB_OFFSET_DB;

#define MIC_CAL_BKP_MAGIC 0x4D43u /* 'MC' */

static uint8_t mic_cal_bkp_load(void)
{
    if (hrtc.Instance == NULL)
        return 0u;

    uint32_t v = HAL_RTCEx_BKUPRead(&hrtc, MIC_CAL_PERSIST_BKP_REG);
    if ((uint16_t)(v >> 16) != (uint16_t)MIC_CAL_BKP_MAGIC)
        return 0u;

    int16_t off_x100 = (int16_t)(v & 0xFFFFu);
    s_cal_db_offset_db = (float)off_x100 / 100.0f;
    return 1u;
}

static uint8_t mic_cal_bkp_save(void)
{
    if (hrtc.Instance == NULL)
        return 0u;

    int32_t off_x100 = (int32_t)(s_cal_db_offset_db * 100.0f + ((s_cal_db_offset_db >= 0.0f) ? 0.5f : -0.5f));
    if (off_x100 > 32767) off_x100 = 32767;
    if (off_x100 < -32768) off_x100 = -32768;

    uint32_t v = ((uint32_t)MIC_CAL_BKP_MAGIC << 16) | (uint16_t)(int16_t)off_x100;
    HAL_RTCEx_BKUPWrite(&hrtc, MIC_CAL_PERSIST_BKP_REG, v);
    return 1u;
}

/* Accumulators for one 50 ms RMS/dBFS window. */
static uint32_t s_win_count;      /* number of PCM samples collected */
static double   s_win_sum_sq;     /* sum(sample^2) for RMS */
static double   s_win_peak;       /* peak amplitude (debug) */
static uint32_t s_decim_phase;    /* decimation phase counter */
static uint32_t s_pcm_fs_hz;      /* estimated PCM sample rate after decimation */
static uint32_t s_win_target_samples;
static uint8_t  s_win_skip;       /* discard first N windows after warm-up */

/* Audio band (applied to both MIC() and MICFFT()). */
typedef struct
{
    float b0, b1, b2;
    float a1, a2; /* a0 assumed 1.0 (already normalized) */
    float z1, z2; /* DF2T state */
} biquad_df2t_t;

static biquad_df2t_t s_band_hp[2];
static biquad_df2t_t s_band_lp[2];

/* Smart warm-up: start measuring only after DATA is active. */
static uint8_t  s_meas_started;
static uint32_t s_stuck_t0_ms;

/* =====================================================================================
 * MICFFT (3-band "FFT-like" analysis state)
 * ===================================================================================== */

static uint32_t s_fft_fs_hz;
static float    s_fft_a_lf;    /* low-pass alpha for MICFFT_LF_MAX_HZ */
static float    s_fft_a_mf;    /* low-pass alpha for MICFFT_MF_MAX_HZ */

static float    s_fft_lp_lf;
static float    s_fft_lp_mf;

static uint32_t s_fft_t0_ms;
static uint32_t s_fft_n;
static double   s_fft_sum_sq_lf;
static double   s_fft_sum_sq_mf;
static double   s_fft_sum_sq_hf;

static uint8_t  s_fft_have_bins;
static mic_err_t s_fft_last_err;
static int16_t  s_fft_last_lf_db_x100;
static int16_t  s_fft_last_mf_db_x100;
static int16_t  s_fft_last_hf_db_x100;
static uint8_t  s_fft_skip; /* discard first completed MICFFT window after warm-up */

/* Compile-time power-save settings (MIC_POWERSAVE in mic.h). */
static inline uint32_t mic_get_target_ms(void)
{
    /* 0 = continuous */
    if (MIC_POWERSAVE == 0u) return 0u;

    /*
     * MIC_POWERSAVE is the requested "useful" capture time.
     * If the clock was OFF before start, add MIC_WAKEUP_MS on top.
     */
    uint32_t measure_ms = (uint32_t)MIC_POWERSAVE;

    /* Ensure we can produce at least one RMS window after warm-up. */
    if (measure_ms < (uint32_t)MIC_WINDOW_MS)
        measure_ms = (uint32_t)MIC_WINDOW_MS;

    uint32_t total_ms = measure_ms + (uint32_t)MIC_WAKEUP_MS;
    if (total_ms < measure_ms)
        total_ms = 0xFFFFFFFFu; /* saturate on overflow (defensive) */
    return total_ms;
}

/* last DMA snapshot for CLI dump */
static uint8_t  s_have_last_dma;
static uint32_t s_last_dma_words;

/* last RX quality snapshot (for diagnostics) */
static uint32_t s_last_rx_ms;
static uint32_t s_last_rx_words;
static uint32_t s_last_rx_cnt_0000;
static uint32_t s_last_rx_cnt_ffff;
static uint32_t s_last_rx_transitions;
static uint16_t s_last_rx_minw;
static uint16_t s_last_rx_maxw;
static uint16_t s_last_rx_first[8];
static uint32_t s_last_rx_first_n;

const uint16_t* MIC_DebugLastDmaBuf(uint32_t *out_words)
{
    if (out_words) *out_words = s_last_dma_words;
    return s_have_last_dma ? s_rx_buf : NULL;
}

/* Optional one-shot capture mode used for power-save measurements. */
static uint8_t  s_interval_active;
static uint32_t s_interval_t0_ms;

/* Debug logging helper. */
#define MIC_DBG(...) do { if (s_debug) printf(__VA_ARGS__); } while (0)

/* Error handling + dBFS conversion helpers. */
static float safe_dbfs_from_rms(float rms)
{
    /* Avoid log(0). */
    if (rms < 1e-6f) return -120.0f;
    return 20.0f * log10f(rms);
}

static float mic_rms_apply_cal(float rms)
{
    float r = rms;
    if (r < 0.0f) r = 0.0f;
    r *= s_cal_rms_gain;
    if (r < 0.0f) r = 0.0f;
    return r;
}

static float mic_dbfs_apply_cal(float dbfs)
{
    return dbfs + s_cal_db_offset_db;
}

static void set_error(mic_err_t e, const char *msg)
{
    s_last_err = e;
    s_last_err_msg = msg;
    if (msg && s_debug)
        printf("[MIC] %s\r\n", msg);
}

static uint32_t mic_pcm_fs_hz(void);
static float mic_lp_alpha_from_fc(uint32_t fc_hz, uint32_t fs_hz);

static inline void biquad_reset(biquad_df2t_t *s)
{
    if (s == NULL) return;
    s->z1 = 0.0f;
    s->z2 = 0.0f;
}

static inline float biquad_step(biquad_df2t_t *s, float x)
{
    /* Direct Form II Transposed */
    float y = s->b0 * x + s->z1;
    s->z1 = s->b1 * x - s->a1 * y + s->z2;
    s->z2 = s->b2 * x - s->a2 * y;
    return y;
}

static void biquad_design_lp(biquad_df2t_t *s, uint32_t fc_hz, uint32_t fs_hz, float q)
{
    if (s == NULL || fs_hz == 0u) return;

    float fs = (float)fs_hz;
    float fc = (float)fc_hz;
    if (fc < 1.0f) fc = 1.0f;
    float fc_max = 0.45f * fs;
    if (fc > fc_max) fc = fc_max;

    if (q < 0.1f) q = 0.1f;

    float w0 = 6.28318530718f * (fc / fs);
    float cs = cosf(w0);
    float sn = sinf(w0);
    float alpha = sn / (2.0f * q);

    float b0 = (1.0f - cs) * 0.5f;
    float b1 = (1.0f - cs);
    float b2 = (1.0f - cs) * 0.5f;
    float a0 = 1.0f + alpha;
    float a1 = -2.0f * cs;
    float a2 = 1.0f - alpha;

    s->b0 = b0 / a0;
    s->b1 = b1 / a0;
    s->b2 = b2 / a0;
    s->a1 = a1 / a0;
    s->a2 = a2 / a0;
    biquad_reset(s);
}

static void biquad_design_hp(biquad_df2t_t *s, uint32_t fc_hz, uint32_t fs_hz, float q)
{
    if (s == NULL || fs_hz == 0u) return;

    float fs = (float)fs_hz;
    float fc = (float)fc_hz;
    if (fc < 1.0f) fc = 1.0f;
    float fc_max = 0.45f * fs;
    if (fc > fc_max) fc = fc_max;

    if (q < 0.1f) q = 0.1f;

    float w0 = 6.28318530718f * (fc / fs);
    float cs = cosf(w0);
    float sn = sinf(w0);
    float alpha = sn / (2.0f * q);

    float b0 = (1.0f + cs) * 0.5f;
    float b1 = -(1.0f + cs);
    float b2 = (1.0f + cs) * 0.5f;
    float a0 = 1.0f + alpha;
    float a1 = -2.0f * cs;
    float a2 = 1.0f - alpha;

    s->b0 = b0 / a0;
    s->b1 = b1 / a0;
    s->b2 = b2 / a0;
    s->a1 = a1 / a0;
    s->a2 = a2 / a0;
    biquad_reset(s);
}

static void mic_update_rates(void)
{
    s_pcm_fs_hz = mic_pcm_fs_hz();

    /* Common audio band (HP/LP) for MIC() RMS and MICFFT(). */
    uint32_t fs_for_filters = s_pcm_fs_hz;
    if (fs_for_filters == 0u) fs_for_filters = 6000u; /* defensive fallback */

    /* 4th-order Butterworth = cascade two biquads with these Q values. */
    const float q1 = 0.54119610f;
    const float q2 = 1.30656296f;
    biquad_design_hp(&s_band_hp[0], MIC_BAND_HP_HZ, fs_for_filters, q1);
    biquad_design_hp(&s_band_hp[1], MIC_BAND_HP_HZ, fs_for_filters, q2);
    biquad_design_lp(&s_band_lp[0], MIC_BAND_LP_HZ, fs_for_filters, q1);
    biquad_design_lp(&s_band_lp[1], MIC_BAND_LP_HZ, fs_for_filters, q2);

    if (s_pcm_fs_hz == 0u)
    {
        /* Fallback to the previous fixed assumption (~6 kHz). */
        s_win_target_samples = 313u;
        return;
    }

    uint32_t target = (s_pcm_fs_hz * (uint32_t)MIC_WINDOW_MS + 500u) / 1000u;
    if (target == 0u) target = 1u;
    s_win_target_samples = target;
}

static uint32_t mic_spi_prescaler_div(uint32_t prescaler)
{
    switch (prescaler)
    {
        case SPI_BAUDRATEPRESCALER_2:   return 2u;
        case SPI_BAUDRATEPRESCALER_4:   return 4u;
        case SPI_BAUDRATEPRESCALER_8:   return 8u;
        case SPI_BAUDRATEPRESCALER_16:  return 16u;
        case SPI_BAUDRATEPRESCALER_32:  return 32u;
        case SPI_BAUDRATEPRESCALER_64:  return 64u;
        case SPI_BAUDRATEPRESCALER_128: return 128u;
        case SPI_BAUDRATEPRESCALER_256: return 256u;
        default:                        return 2u;
    }
}

static uint32_t mic_spi_bits_per_word(void)
{
    /* CubeMX config uses 16-bit. Keep fallback defensive. */
    if (hspi1.Init.DataSize == SPI_DATASIZE_16BIT) return 16u;
    if (hspi1.Init.DataSize == SPI_DATASIZE_8BIT)  return 8u;
    return 16u;
}

static uint32_t mic_pcm_fs_hz(void)
{
    /*
     * We treat each received SPI word as one CIC input sample (it represents 16 PDM bits via popcount).
     * Therefore the CIC input sample rate is: fs_in = SPI_SCK / bits_per_word.
     * After MIC_DECIM_N, PCM fs is: fs = fs_in / MIC_DECIM_N.
     */
    uint32_t pclk = HAL_RCC_GetPCLK1Freq();
    if (pclk == 0u) pclk = HAL_RCC_GetHCLKFreq();
    if (pclk == 0u) return 0u;

    uint32_t div  = mic_spi_prescaler_div(hspi1.Init.BaudRatePrescaler);
    uint32_t sck  = pclk / div;
    uint32_t bits = mic_spi_bits_per_word();
    if (bits == 0u) return 0u;

    uint32_t fs_in = sck / bits;
    if (MIC_DECIM_N == 0u) return 0u;
    return fs_in / MIC_DECIM_N;
}

static float mic_lp_alpha_from_fc(uint32_t fc_hz, uint32_t fs_hz)
{
    if (fs_hz == 0u || fc_hz == 0u) return 0.0f;

    float fs = (float)fs_hz;
    float fc = (float)fc_hz;

    /* Clamp for stability if configuration/sample-rate makes fc too high. */
    float fc_max = 0.45f * fs;
    if (fc > fc_max) fc = fc_max;
    if (fc < 1.0f) fc = 1.0f;

    /* alpha = 2*pi*fc / (2*pi*fc + fs) */
    const float two_pi = 6.28318530718f;
    float w = two_pi * fc;
    float a = w / (w + fs);
    if (a < 0.0f) a = 0.0f;
    if (a > 1.0f) a = 1.0f;
    return a;
}

static inline float mic_lp_step(float x, float *state, float alpha)
{
    *state += alpha * (x - *state);
    return *state;
}

static void mic_band_reset(void)
{
    biquad_reset(&s_band_hp[0]);
    biquad_reset(&s_band_hp[1]);
    biquad_reset(&s_band_lp[0]);
    biquad_reset(&s_band_lp[1]);
}

static inline float mic_band_step(float x)
{
    float y = x;
    if (MIC_BAND_HP_HZ != 0u)
    {
        y = biquad_step(&s_band_hp[0], y);
        y = biquad_step(&s_band_hp[1], y);
    }
    if (MIC_BAND_LP_HZ != 0u)
    {
        y = biquad_step(&s_band_lp[0], y);
        y = biquad_step(&s_band_lp[1], y);
    }
    return y;
}

static int16_t mic_dbfs_to_x100_i16(float dbfs)
{
    /* Round to centi-dB and clamp to int16. */
    float x = dbfs * 100.0f;
    int32_t v = (x >= 0.0f) ? (int32_t)(x + 0.5f) : (int32_t)(x - 0.5f);
    if (v > 32767) v = 32767;
    if (v < -32768) v = -32768;
    return (int16_t)v;
}

static void micfft_invalidate(mic_err_t e)
{
    s_fft_have_bins = 0u;
    s_fft_last_err = e;
    s_fft_t0_ms = 0u;
    s_fft_n = 0u;
    s_fft_sum_sq_lf = 0.0;
    s_fft_sum_sq_mf = 0.0;
    s_fft_sum_sq_hf = 0.0;
}

static void micfft_reset(void)
{
    s_fft_fs_hz = mic_pcm_fs_hz();
    s_fft_a_lf = mic_lp_alpha_from_fc(MICFFT_LF_MAX_HZ, s_fft_fs_hz);
    s_fft_a_mf = mic_lp_alpha_from_fc(MICFFT_MF_MAX_HZ, s_fft_fs_hz);

    s_fft_lp_lf = 0.0f;
    s_fft_lp_mf = 0.0f;

    s_fft_last_lf_db_x100 = -12000;
    s_fft_last_mf_db_x100 = -12000;
    s_fft_last_hf_db_x100 = -12000;

    s_fft_skip = 1u;
    micfft_invalidate(MIC_ERR_NO_DATA_YET);
}

static void micfft_feed_sample(float x)
{
    if (MICFFT_WINDOW_MS == 0u) return;
    if (s_fft_fs_hz == 0u) return;

    /* Input is already band-limited by MIC_BAND_HP_HZ..MIC_BAND_LP_HZ. */
    float x_band = x;

    /* Two low-pass splits: LF cutoff and MF cutoff (3 bins total). */
    float lp_lf = mic_lp_step(x_band, &s_fft_lp_lf, s_fft_a_lf);
    float lp_mf = mic_lp_step(x_band, &s_fft_lp_mf, s_fft_a_mf);

    float lf = lp_lf;
    float mf = lp_mf - lp_lf;
    float hf = x_band - lp_mf;

    double dlf = (double)lf;
    double dmf = (double)mf;
    double dhf = (double)hf;

    if (s_fft_n == 0u)
        s_fft_t0_ms = HAL_GetTick();

    s_fft_sum_sq_lf += dlf * dlf;
    s_fft_sum_sq_mf += dmf * dmf;
    s_fft_sum_sq_hf += dhf * dhf;
    s_fft_n++;

    uint32_t now = HAL_GetTick();
    if ((now - s_fft_t0_ms) < (uint32_t)MICFFT_WINDOW_MS)
        return;

    if (s_fft_n == 0u)
        return;

    /* Discard the very first FFT window after warm-up to let filters settle. */
    if (s_fft_skip)
    {
        s_fft_skip--;
        micfft_invalidate(MIC_ERR_NO_DATA_YET);
        return;
    }

    float rms_lf = (float)sqrt(s_fft_sum_sq_lf / (double)s_fft_n);
    float rms_mf = (float)sqrt(s_fft_sum_sq_mf / (double)s_fft_n);
    float rms_hf = (float)sqrt(s_fft_sum_sq_hf / (double)s_fft_n);

    float db_lf = mic_dbfs_apply_cal(safe_dbfs_from_rms(mic_rms_apply_cal(rms_lf)));
    float db_mf = mic_dbfs_apply_cal(safe_dbfs_from_rms(mic_rms_apply_cal(rms_mf)));
    float db_hf = mic_dbfs_apply_cal(safe_dbfs_from_rms(mic_rms_apply_cal(rms_hf)));

    s_fft_last_lf_db_x100 = mic_dbfs_to_x100_i16(db_lf);
    s_fft_last_mf_db_x100 = mic_dbfs_to_x100_i16(db_mf);
    s_fft_last_hf_db_x100 = mic_dbfs_to_x100_i16(db_hf);

    s_fft_have_bins = 1u;
    s_fft_last_err = MIC_ERR_OK;

    /* Reset for next window. */
    s_fft_t0_ms = now;
    s_fft_n = 0u;
    s_fft_sum_sq_lf = 0.0;
    s_fft_sum_sq_mf = 0.0;
    s_fft_sum_sq_hf = 0.0;
}

/* PDM->PCM pipeline: CIC + decimation + short FIR smoothing (feeds RMS accumulator). */

/* CIC state (single channel), 3rd-order CIC decimator (sinc^3) at the "word rate".
 * This provides a much stronger low-pass than a single boxcar, reducing noise-folding
 * from the PDM noise-shaped spectrum into the audio band.
 *
 * NOTE: Integrators run continuously and would overflow in signed arithmetic; we
 * intentionally keep them modulo 2^32 using uint32_t (defined wrap-around).
 */
typedef struct
{
    uint32_t i1, i2, i3; /* integrators */
    uint32_t d1, d2, d3; /* comb delays (at decimated rate) */
} cic3_u32_t;

static cic3_u32_t s_cic3;

/* FIR moving average (simple low-pass). */
static int32_t s_fir_hist[MIC_FIR_TAPS];
static uint32_t s_fir_pos;

static void pdm2pcm_reset(void)
{
    memset(&s_cic3, 0, sizeof(s_cic3));
    s_decim_phase = 0u;
    memset(s_fir_hist, 0, sizeof(s_fir_hist));
    s_fir_pos = 0u;
}

static inline uint8_t popcount16_inline(uint16_t x)
{
    uint8_t c = 0;
    while (x)
    {
        x &= (uint16_t)(x - 1u);
        c++;
    }
    return c;
}

/* Convert 16 PDM bits into a signed CIC input in range [-16..+16]. */
static inline int32_t pdm_word_to_cic_input(uint16_t w)
{
    int32_t ones = (int32_t)popcount16_inline(w);
    return (2 * ones) - 16;
}

static inline int32_t cic_u32_to_s32(uint32_t u)
{
    /* Convert modulo 2^32 value to signed int32 (two's complement) without UB. */
    if (u <= 0x7FFFFFFFu) return (int32_t)u;
    return (int32_t)((int64_t)u - 0x100000000LL);
}

static inline uint8_t pdm2pcm_push(int32_t cic_in, float *out_pcm)
{
    /* 3-stage CIC integrators (modulo arithmetic). */
    s_cic3.i1 += (uint32_t)cic_in;
    s_cic3.i2 += s_cic3.i1;
    s_cic3.i3 += s_cic3.i2;

    s_decim_phase++;
    if (s_decim_phase < MIC_DECIM_N)
        return 0u;

    s_decim_phase = 0u;

    /* 3-stage combs at the decimated rate. */
    uint32_t c1u = s_cic3.i3 - s_cic3.d1; s_cic3.d1 = s_cic3.i3;
    uint32_t c2u = c1u      - s_cic3.d2; s_cic3.d2 = c1u;
    uint32_t c3u = c2u      - s_cic3.d3; s_cic3.d3 = c2u;
    int32_t comb = cic_u32_to_s32(c3u);

    /* FIR moving average on the decimated stream. */
    s_fir_hist[s_fir_pos] = comb;
    s_fir_pos = (s_fir_pos + 1u) % MIC_FIR_TAPS;

    int64_t acc = 0;
    for (uint32_t i = 0; i < MIC_FIR_TAPS; i++)
        acc += (int64_t)s_fir_hist[i];

    /* Normalize to roughly [-1..1] (not calibrated) and clamp for stability. */
    uint32_t r = (uint32_t)MIC_DECIM_N;
    uint32_t r3 = r * r * r;
    if (r3 == 0u) r3 = 1u;
    float y = (float)acc / (float)(MIC_FIR_TAPS * 16u * r3);
    if (y > 1.0f) y = 1.0f;
    if (y < -1.0f) y = -1.0f;
    if (out_pcm) *out_pcm = y;
    return 1u;
}

/* HAL callbacks (DMA completion / error). */
void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi == &hspi1)
    {
        s_spi_half = 1u;
        s_dma_last_evt_ms = HAL_GetTick();
        s_cb_half_count++;
        s_cb_half_last_ms = s_dma_last_evt_ms;
    }
}

void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi == &hspi1)
    {
        s_spi_done = 1u;
        s_dma_last_evt_ms = HAL_GetTick();
        s_cb_full_count++;
        s_cb_full_last_ms = s_dma_last_evt_ms;
    }
}

void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi == &hspi1)
    {
        s_spi_err = 1u;
        s_dma_last_evt_ms = HAL_GetTick();
        s_cb_err_count++;
        s_cb_err_last_ms = s_dma_last_evt_ms;
    }
}

/* Start one SPI RX DMA block (non-circular, processed in software). */
static mic_err_t start_dma_block(void)
{
    /* Fill with 0xAA so we can detect "DMA wrote nothing" cases. */
    memset(s_rx_buf, 0xAA, sizeof(s_rx_buf));

    s_have_last_dma = 0u;
    s_last_dma_words = MIC_DMA_WORDS;

    s_dma_circular = 0u;
    s_spi_done = 0u;
    s_spi_half = 0u;
    s_spi_err  = 0u;

    /* Basic sanity checks before starting DMA. */
    if (hspi1.Instance != SPI1)
    {
        set_error(MIC_ERR_NOT_INIT, "ERROR: SPI1 not initialized (hspi1.Instance != SPI1)");
        return MIC_ERR_NOT_INIT;
    }

    if (HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY)
    {
        set_error(MIC_ERR_SPI_NOT_READY, "ERROR: SPI not READY (busy from other code?)");
        return MIC_ERR_SPI_NOT_READY;
    }

    /* Start RX DMA (count is in 16-bit elements with the current SPI/DMA config). */
    HAL_StatusTypeDef st = HAL_SPI_Receive_DMA(&hspi1, (uint8_t*)s_rx_buf, MIC_DMA_WORDS);
    if (st != HAL_OK)
    {
        set_error(MIC_ERR_START_DMA, "ERROR: HAL_SPI_Receive_DMA failed");
        if (s_debug)
            printf("[MIC] HAL st=%d state=%d err=0x%08lX\r\n", (int)st, (int)HAL_SPI_GetState(&hspi1), (unsigned long)hspi1.ErrorCode);
        return MIC_ERR_START_DMA;
    }

    /* For debug: BUSY means SPI is actively generating CLOCK on PA5. */
    s_dma_t0_ms = HAL_GetTick();
    s_dma_last_evt_ms = s_dma_t0_ms;

    /* Detect circular DMA configuration (CubeMX). */
    if (hspi1.hdmarx && hspi1.hdmarx->Instance)
    {
        if ((hspi1.hdmarx->Instance->CCR & DMA_CCR_CIRC) == DMA_CCR_CIRC)
            s_dma_circular = 1u;
    }

    MIC_DBG("[MIC] DMA started. SPI state=%d (2=BUSY => CLOCK on PA5)\r\n", (int)HAL_SPI_GetState(&hspi1));
    return MIC_ERR_OK;
}

static mic_err_t process_words_and_update_window(const uint16_t *buf, uint32_t words)
{
    if (!buf || words == 0u)
        return MIC_ERR_OK;

    /* Quick RX quality stats (helps debug without an oscilloscope). */
    uint32_t cnt_0000 = 0u;
    uint32_t cnt_ffff = 0u;
    uint32_t transitions = 0u;
    uint16_t minw = 0xFFFFu;
    uint16_t maxw = 0x0000u;
    uint16_t prev = 0u;
    uint8_t have_prev = 0u;
    uint32_t first_n = 0u;

    /* Detect "DMA wrote nothing" by checking the 0xAAAA fill pattern. */
    uint32_t still_aa = 0;
    for (uint32_t i = 0; i < words; i++)
        if (buf[i] == 0xAAAAu) still_aa++;

    if (still_aa == words)
    {
        set_error(MIC_ERR_DMA_NO_WRITE, "ERROR: DMA completed but buffer unchanged (0xAAAA) -> DMA not writing");
        micfft_invalidate(MIC_ERR_DMA_NO_WRITE);
        return MIC_ERR_DMA_NO_WRITE;
    }

    /* Save last block for CLI debug dump. */
    s_have_last_dma = 1u;
    s_last_dma_words = MIC_DMA_WORDS;

    uint32_t now_ms = HAL_GetTick();
    uint32_t elapsed_ms = now_ms - s_capture_t0_ms;

    uint8_t time_ready = 1u;
    if (MIC_WAKEUP_MS != 0u)
    {
        if (elapsed_ms < (uint32_t)MIC_WAKEUP_MS) time_ready = 0u;
    }

    /* Quick data-quality check: detect stuck DATA (all 0x0000/0xFFFF) -> RMS ~= 1.0. */
    for (uint32_t i = 0; i < words; i++)
    {
        uint16_t w = buf[i];

        if (first_n < (uint32_t)(sizeof(s_last_rx_first) / sizeof(s_last_rx_first[0])))
            s_last_rx_first[first_n++] = w;

        if (w == 0x0000u) cnt_0000++;
        if (w == 0xFFFFu) cnt_ffff++;

        if (w < minw) minw = w;
        if (w > maxw) maxw = w;

        if (have_prev)
        {
            if (w != prev) transitions++;
        }
        else
        {
            have_prev = 1u;
        }
        prev = w;
    }

    s_last_rx_ms = now_ms;
    s_last_rx_words = words;
    s_last_rx_cnt_0000 = cnt_0000;
    s_last_rx_cnt_ffff = cnt_ffff;
    s_last_rx_transitions = transitions;
    s_last_rx_minw = minw;
    s_last_rx_maxw = maxw;
    s_last_rx_first_n = first_n;

    uint32_t bad_count = cnt_0000 + cnt_ffff;

    uint8_t data_stuck = (bad_count == words) ? 1u : 0u;
    uint8_t data_active = 0u;
    if ((bad_count < words) && (minw != maxw) && (transitions > 0u))
        data_active = 1u;

    /*
     * If all words are stuck (all 0x0000/0xFFFF) after warmup:
     * - still allow a small grace period for the mic to begin driving DATA
     *   (some parts start slightly later than MIC_WAKEUP_MS),
     * - then treat it as a hard wiring/clock issue.
     */
    if ((!s_meas_started) && time_ready && data_stuck)
    {
        uint32_t startup_grace_ms = (uint32_t)MIC_WAKEUP_MS + (uint32_t)MIC_WINDOW_MS;
        if (startup_grace_ms < (uint32_t)MIC_WAKEUP_MS)
            startup_grace_ms = 0xFFFFFFFFu;

        if (elapsed_ms < startup_grace_ms)
        {
            /* Keep waiting: do not poison the error state yet. */
            return MIC_ERR_OK;
        }

        set_error(MIC_ERR_DATA_STUCK, "ERROR: PDM DATA stuck (all 0x0000 or 0xFFFF)");
        micfft_invalidate(MIC_ERR_DATA_STUCK);
        return MIC_ERR_DATA_STUCK;
    }

    /* Smart warm-up: do not start measuring until time has elapsed AND data is active. */
    if (!s_meas_started)
    {
        if (!time_ready || !data_active)
        {
            /* Keep waiting: no valid data to measure yet. */
            return MIC_ERR_OK;
        }

        /* First active block after warm-up: start from a clean DSP state. */
        s_meas_started = 1u;
        s_stuck_t0_ms = 0u;

        s_win_count  = 0u;
        s_win_sum_sq = 0.0;
        s_win_peak   = 0.0;
        s_decim_phase = 0u;
        s_win_skip   = 1u;

        mic_band_reset();
        pdm2pcm_reset();
        micfft_reset();

        /* Discard this "transitional" DMA block (may still contain stuck words). */
        return MIC_ERR_OK;
    }

    /* If data gets stuck during measurement, debounce briefly then report. */
    if (data_stuck)
    {
        if (s_stuck_t0_ms == 0u)
            s_stuck_t0_ms = now_ms;

        /* Ignore very short glitches so a single bad DMA block doesn't fail MIC(). */
        if ((now_ms - s_stuck_t0_ms) < 20u)
            return MIC_ERR_OK;

        set_error(MIC_ERR_DATA_STUCK, "ERROR: PDM DATA stuck (all 0x0000 or 0xFFFF)");
        micfft_invalidate(MIC_ERR_DATA_STUCK);
        return MIC_ERR_DATA_STUCK;
    }
    s_stuck_t0_ms = 0u;

    /* PDM->PCM + decimation + RMS accumulator update. */
    for (uint32_t i = 0; i < words; i++)
    {
        /* CIC input derived from 16 PDM bits. */
        int32_t cic_in = pdm_word_to_cic_input(buf[i]);

        float s = 0.0f;
        if (!pdm2pcm_push(cic_in, &s))
            continue;

        float x_band = mic_band_step(s);
        micfft_feed_sample(x_band);

        /* Accumulate RMS window. */
        double sd = (double)x_band;
        s_win_sum_sq += sd * sd;

        double a = (sd >= 0.0) ? sd : -sd;
        if (a > s_win_peak) s_win_peak = a;

        s_win_count++;

        /* When the window is full, finalize RMS/dBFS and store the result. */
        if (s_win_count >= s_win_target_samples)
        {
            float rms = (float)sqrt(s_win_sum_sq / (double)s_win_count);
            float dbfs = mic_dbfs_apply_cal(safe_dbfs_from_rms(mic_rms_apply_cal(rms)));

            /* Guard against suspicious saturation (often wiring/clock/polarity issues). */
            if (rms > 0.98f || s_win_peak > 0.98)
            {
                MIC_DBG("[MIC] WARNING: saturation suspected: rms=%.4f peak=%.4f\r\n", (double)rms, (double)s_win_peak);
                set_error(MIC_ERR_SIGNAL_SATURATED, "ERROR: signal saturated (RMS/PEAK ~ 1.0) - likely DATA stuck or wrong clock/polarity");
                micfft_invalidate(MIC_ERR_SIGNAL_SATURATED);

                /* Reset window so we don't get stuck returning the same error forever. */
                s_win_count  = 0u;
                s_win_sum_sq = 0.0;
                s_win_peak   = 0.0;
                return MIC_ERR_SIGNAL_SATURATED;
            }

            /* Discard the very first full window after warm-up to let CIC/IIR settle. */
            if (s_win_skip)
            {
                s_win_skip--;
                s_last_err = MIC_ERR_NO_DATA_YET;
                s_last_err_msg = "no data yet";
                s_win_count  = 0u;
                s_win_sum_sq = 0.0;
                s_win_peak   = 0.0;
                continue;
            }

            s_last_rms  = rms;
            s_last_dbfs = dbfs;
            s_last_err  = MIC_ERR_OK;
            s_last_err_msg = NULL;
            s_last_seq++;

            MIC_DBG("[MIC] 50ms window ready: n=%lu rms=%.4f dbfs=%.2f peak=%.4f\r\n",
                    (unsigned long)s_win_count, (double)rms, (double)dbfs, (double)s_win_peak);

            /* Reset window for the next measurement. */
            s_win_count  = 0u;
            s_win_sum_sq = 0.0;
            s_win_peak   = 0.0;
        }
    }

    return MIC_ERR_OK;
}

/* =====================================================================================
 * PUBLIC API (driver)
 * ===================================================================================== */

void MIC_SetDebug(uint8_t enable)
{
    s_debug = (enable != 0u) ? 1u : 0u;
}

void MIC_Init(void)
{
    /* SPI/DMA are initialized by CubeMX; MIC_Init only resets driver state. */
    s_inited = 1u;
    s_running = 0u;
    s_last_err = MIC_ERR_NOT_INIT;
    s_last_err_msg = "not started";
    s_dma_t0_ms = 0u;
    s_capture_t0_ms = 0u;

    s_win_count  = 0u;
    s_win_sum_sq = 0.0;
    s_win_peak   = 0.0;
    s_decim_phase = 0u;
    s_win_skip   = 0u;
    mic_band_reset();
    s_meas_started = 0u;
    s_stuck_t0_ms  = 0u;

    s_last_dbfs = -120.0f;
    s_last_rms  = 0.0f;
    s_last_seq  = 0u;

    MIC_CalResetToDefaults();
    (void)MIC_CalLoad();

    /* debug default off */
    /* Keep s_debug as set before init. */

    s_interval_active = 0u;
    s_interval_t0_ms  = 0u;
    s_have_last_dma   = 0u;
    s_last_dma_words  = MIC_DMA_WORDS;

    s_cb_half_count = 0u;
    s_cb_full_count = 0u;
    s_cb_err_count  = 0u;
    s_cb_half_last_ms = 0u;
    s_cb_full_last_ms = 0u;
    s_cb_err_last_ms  = 0u;
    s_cb_start_ms = 0u;
    s_cb_full_start_count = 0u;

    s_last_rx_ms = 0u;
    s_last_rx_words = 0u;
    s_last_rx_cnt_0000 = 0u;
    s_last_rx_cnt_ffff = 0u;
    s_last_rx_transitions = 0u;
    s_last_rx_minw = 0u;
    s_last_rx_maxw = 0u;
    memset(s_last_rx_first, 0, sizeof(s_last_rx_first));
    s_last_rx_first_n = 0u;

    s_capture_t0_ms = 0u;
    pdm2pcm_reset();
    mic_update_rates();
    micfft_reset();

    MIC_DBG("[MIC] Init done. Window=%ums, target_samples=%lu, decim=%u, fs=%luHz\r\n",
            (unsigned)MIC_WINDOW_MS,
            (unsigned long)s_win_target_samples,
            (unsigned)MIC_DECIM_N,
            (unsigned long)s_pcm_fs_hz);
}

mic_err_t MIC_Start(void)
{
    if (!s_inited)
    {
        set_error(MIC_ERR_NOT_INIT, "ERROR: MIC_Start called before MIC_Init");
        return MIC_ERR_NOT_INIT;
    }

    if (s_running)
        return MIC_ERR_OK;

    s_capture_t0_ms = HAL_GetTick();
    s_cb_start_ms = s_capture_t0_ms;
    s_cb_full_start_count = s_cb_full_count;
    mic_update_rates();

    /* Start the first DMA block. */
    mic_err_t e = start_dma_block();
    if (e != MIC_ERR_OK)
        return e;

    /* Reset PDM->PCM state for each new measurement (continuous or one-shot). */
    pdm2pcm_reset();
    micfft_reset();

    s_running = 1u;

    /* Reset measurement state (warm-up + first valid block starts clean). */
    s_meas_started = 0u;
    s_stuck_t0_ms  = 0u;
    mic_band_reset();
    s_win_count    = 0u;
    s_win_sum_sq   = 0.0;
    s_win_peak     = 0.0;
    s_decim_phase  = 0u;
    s_win_skip     = 0u;
    s_last_seq     = 0u;

    /* interval mode setup */
    if (mic_get_target_ms() != 0u)
    {
        s_interval_active = 1u;
        s_interval_t0_ms  = HAL_GetTick();

        /* Reset accumulators for one-shot interval measurement. */
        s_win_count  = 0u;
        s_win_sum_sq = 0.0;
        s_win_peak   = 0.0;
        s_decim_phase = 0u;

        /* Placeholder result until the first window completes. */
        s_last_rms  = 0.0f;
        s_last_dbfs = -120.0f;
        s_last_err  = MIC_ERR_NO_DATA_YET;
        s_last_err_msg = "no data yet";

        MIC_DBG("[MIC] PowerSave compile-time: capture %lu ms then stop\r\n", (unsigned long)mic_get_target_ms());
    }
    else
    {
        s_interval_active = 0u;
        s_last_err = MIC_ERR_NO_DATA_YET;
        s_last_err_msg = "no data yet";
    }

    return MIC_ERR_OK;
}

void MIC_Stop(void)
{
    if (!s_running)
    {
        s_interval_active = 0u;
        return;
    }

    (void)HAL_SPI_Abort(&hspi1);
    s_running = 0u;
    s_interval_active = 0u;
    s_dma_circular = 0u;
    s_spi_done = 0u;
    s_spi_half = 0u;
    s_spi_err = 0u;
}

void MIC_Task(void)
{
    /* Periodic driver task: advances DMA capture and updates the 50 ms RMS window. */
    if (!s_inited)
        return;

    if (!s_running)
        return;

    /* Abort on SPI error. */
    if (s_spi_err)
    {
        set_error(MIC_ERR_SPI_ERROR, "ERROR: SPI error during capture");
        micfft_invalidate(MIC_ERR_SPI_ERROR);
        MIC_Stop();
        return;
    }

    /* Circular DMA mode: continuous clock, process half/full buffers without restart. */
    if (s_dma_circular)
    {
        /* Timeout if DMA callbacks stop arriving. */
        if ((HAL_GetTick() - s_dma_last_evt_ms) > MIC_TIMEOUT_MS)
        {
            set_error(MIC_ERR_TIMEOUT, "ERROR: DMA timeout (no circular DMA events)");
            micfft_invalidate(MIC_ERR_TIMEOUT);
            MIC_Stop();
            return;
        }

        uint32_t half_words = MIC_DMA_WORDS / 2u;
        uint32_t rest_words = MIC_DMA_WORDS - half_words;
        if (half_words == 0u)
            return;

        if (s_spi_half)
        {
            s_spi_half = 0u;
            (void)process_words_and_update_window(&s_rx_buf[0], half_words);
        }

        if (s_spi_done)
        {
            s_spi_done = 0u;
            (void)process_words_and_update_window(&s_rx_buf[half_words], rest_words);
        }

        /* Interval mode stop condition (if enabled at compile-time). */
        if (s_interval_active)
        {
            uint32_t elapsed = HAL_GetTick() - s_interval_t0_ms;
            uint32_t target  = mic_get_target_ms();
            if (elapsed >= target)
            {
                if (s_last_err == MIC_ERR_NO_DATA_YET)
                {
                    set_error(MIC_ERR_TIMEOUT, "ERROR: interval finished but no valid window");
                    micfft_invalidate(MIC_ERR_TIMEOUT);
                }
                MIC_Stop();
                s_interval_active = 0u;
            }
        }

        return;
    }

    /* If DMA is not done yet, only check for timeout. */
    if (!s_spi_done)
    {
        if ((HAL_GetTick() - s_dma_t0_ms) > MIC_TIMEOUT_MS)
        {
            set_error(MIC_ERR_TIMEOUT, "ERROR: DMA timeout waiting for RxCplt");
            micfft_invalidate(MIC_ERR_TIMEOUT);
            MIC_Stop();
        }
        return;
    }
    s_spi_done = 0u;

    /* DMA complete: process the received block. */
    (void)process_words_and_update_window(s_rx_buf, MIC_DMA_WORDS);

    if (s_interval_active)
    {
        uint32_t elapsed = HAL_GetTick() - s_interval_t0_ms;
        uint32_t target  = mic_get_target_ms();

        if (elapsed >= target)
        {
            if (s_last_err == MIC_ERR_NO_DATA_YET)
            {
                set_error(MIC_ERR_TIMEOUT, "ERROR: interval finished but no valid window");
                mic_err_t e = MIC_ERR_TIMEOUT;
                micfft_invalidate(e);
            }
            MIC_Stop();
            s_interval_active = 0u;
            return;
        }

        (void)start_dma_block();
        return;
    }

    /* Continuous mode: always restart DMA. */
    if (mic_get_target_ms() == 0u)
        (void)start_dma_block();
}

mic_err_t MIC_GetLast50ms(float *out_dbfs, float *out_rms)
{
    /* In interval mode, auto-start capture on first read. */
    if (s_inited && (mic_get_target_ms() != 0u) && (!s_running) && (!s_interval_active))
    {
        (void)MIC_Start();
    }

    if (out_dbfs) *out_dbfs = (s_last_err == MIC_ERR_OK) ? s_last_dbfs : 0.0f;
    if (out_rms)  *out_rms  = (s_last_err == MIC_ERR_OK) ? s_last_rms  : 0.0f;
    return s_last_err;
}

mic_err_t MIC_GetLast50msEx(float *out_dbfs, float *out_rms, uint32_t *out_seq)
{
    mic_err_t st = MIC_GetLast50ms(out_dbfs, out_rms);
    if (out_seq) *out_seq = s_last_seq;
    return st;
}

void MIC_CalResetToDefaults(void)
{
    s_cal_rms_gain     = (float)MIC_CAL_RMS_GAIN;
    s_cal_db_offset_db = (float)MIC_CAL_DB_OFFSET_DB;
}

void MIC_CalGet(float *out_rms_gain, float *out_db_offset_db)
{
    if (out_rms_gain) *out_rms_gain = s_cal_rms_gain;
    if (out_db_offset_db) *out_db_offset_db = s_cal_db_offset_db;
}

void MIC_CalSet(float rms_gain, float db_offset_db)
{
    s_cal_rms_gain = rms_gain;
    s_cal_db_offset_db = db_offset_db;
}

uint8_t MIC_CalLoad(void)
{
    return mic_cal_bkp_load();
}

uint8_t MIC_CalSave(void)
{
    return mic_cal_bkp_save();
}

static void mic_cal_writef(mic_write_fn_t write, const char *fmt, ...)
{
    if (write == NULL || fmt == NULL)
        return;

    char buf[200];
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);
    write(buf);
}

static void mic_cal_task_delay_ms(uint32_t delay_ms)
{
    uint32_t t0 = HAL_GetTick();
    while ((HAL_GetTick() - t0) < delay_ms)
    {
        MIC_Task();
        HAL_Delay(5);
    }
}

static mic_err_t mic_cal_measure_mean_power_started(uint32_t measure_ms,
                                                    double *out_mean_power,
                                                    uint32_t *out_n_windows,
                                                    mic_write_fn_t write)
{
    if (out_mean_power) *out_mean_power = 0.0;
    if (out_n_windows) *out_n_windows = 0u;

    uint32_t t0 = HAL_GetTick();
    double sum_p = 0.0;
    uint32_t n = 0u;
    uint32_t last_seq = 0u;
    uint8_t have_seq = 0u;

    while ((HAL_GetTick() - t0) < measure_ms)
    {
        MIC_Task();

        float dbfs = 0.0f;
        float rms  = 0.0f;
        uint32_t seq = 0u;
        mic_err_t st = MIC_GetLast50msEx(&dbfs, &rms, &seq);
        if (st == MIC_ERR_OK)
        {
            if (!have_seq || (seq != last_seq))
            {
                double r = (double)rms;
                if (r < 0.0) r = 0.0;
                r *= (double)s_cal_rms_gain;
                if (r < 0.0) r = 0.0;

                sum_p += r * r;
                n++;
                last_seq = seq;
                have_seq = 1u;
            }
        }
        else if (st != MIC_ERR_NO_DATA_YET && st != MIC_ERR_DATA_STUCK)
        {
            const char *msg = MIC_LastErrorMsg();
            mic_cal_writef(write, "ERR miccal mic %s(%ld) msg=%s\r\n",
                           MIC_ErrName(st), (long)st, msg ? msg : "");
            return st;
        }

        HAL_Delay(5);
    }

    if (n == 0u)
    {
        set_error(MIC_ERR_TIMEOUT, "ERROR: miccal no 50ms windows");
        if (write) write("ERR miccal no windows\r\n");
        return MIC_ERR_TIMEOUT;
    }

    if (out_mean_power) *out_mean_power = sum_p / (double)n;
    if (out_n_windows) *out_n_windows = n;
    return MIC_ERR_OK;
}

static mic_err_t mic_calibrate_interactive(float spl_db,
                                          const char *mode_label,
                                          uint8_t auto_beep,
                                          mic_write_fn_t write,
                                          mic_wait_enter_fn_t wait_enter,
                                          mic_beep_fn_t beep)
{
    if (wait_enter == NULL)
    {
        set_error(MIC_ERR_NOT_INIT, "ERROR: miccal wait_enter callback is NULL");
        return MIC_ERR_NOT_INIT;
    }

    const uint8_t was_running = s_running;
    MIC_Stop();
    if (!s_inited)
        MIC_Init();

    if (write)
    {
        write("mic calibration, press ENTER when quiet.\r\n");
    }

    if (!wait_enter((uint32_t)MIC_CAL_WAIT_ENTER_TIMEOUT_MS))
    {
        set_error(MIC_ERR_TIMEOUT, "ERROR: miccal timeout waiting for ENTER (quiet)");
        if (write) write("ERR miccal timeout waiting for ENTER (quiet)\r\n");
        if (was_running) (void)MIC_Start();
        return MIC_ERR_TIMEOUT;
    }

    if (write)
        mic_cal_writef(write, "MICCAL: measuring quiet (%lu ms)...\r\n", (unsigned long)MIC_CAL_MEASURE_MS);

    mic_err_t st = MIC_Start();
    if (st != MIC_ERR_OK)
    {
        const char *msg = MIC_LastErrorMsg();
        mic_cal_writef(write, "ERR miccal start %s(%ld) msg=%s\r\n",
                       MIC_ErrName(st), (long)st, msg ? msg : "");
        if (was_running) (void)MIC_Start();
        return st;
    }

    double quiet_p = 0.0;
    uint32_t n_quiet = 0u;
    st = mic_cal_measure_mean_power_started((uint32_t)MIC_CAL_MEASURE_MS, &quiet_p, &n_quiet, write);
    MIC_Stop();
    if (st != MIC_ERR_OK)
    {
        if (was_running) (void)MIC_Start();
        return st;
    }

    if (write)
    {
        if (auto_beep)
            write("mic calibration, press ENTER when audio (buzzer) is ready.\r\n");
        else
            write("mic calibration, press ENTER when audio is playing.\r\n");
    }

    if (!wait_enter((uint32_t)MIC_CAL_WAIT_ENTER_TIMEOUT_MS))
    {
        set_error(MIC_ERR_TIMEOUT, "ERROR: miccal timeout waiting for ENTER (audio)");
        if (write) write("ERR miccal timeout waiting for ENTER (audio)\r\n");
        if (was_running) (void)MIC_Start();
        return MIC_ERR_TIMEOUT;
    }

    st = MIC_Start();
    if (st != MIC_ERR_OK)
    {
        const char *msg = MIC_LastErrorMsg();
        mic_cal_writef(write, "ERR miccal start %s(%ld) msg=%s\r\n",
                       MIC_ErrName(st), (long)st, msg ? msg : "");
        if (was_running) (void)MIC_Start();
        return st;
    }

    if (auto_beep)
    {
        if (beep == NULL)
        {
            MIC_Stop();
            set_error(MIC_ERR_NOT_INIT, "ERROR: miccal beep callback is NULL");
            if (write) write("ERR miccal beep callback missing\r\n");
            if (was_running) (void)MIC_Start();
            return MIC_ERR_NOT_INIT;
        }

        const uint32_t settle_ms  = (uint32_t)MIC_CAL_AUTO_TONE_SETTLE_MS;
        const uint32_t measure_ms = (uint32_t)MIC_CAL_MEASURE_MS;
        const float beep_time_s   = (float)(settle_ms + measure_ms + 300u) / 1000.0f;
        beep((uint16_t)MIC_CAL_AUTO_TONE_FREQ_HZ, (uint8_t)MIC_CAL_AUTO_TONE_VOL, beep_time_s);

        mic_cal_task_delay_ms(settle_ms);
    }

    if (write)
        mic_cal_writef(write, "MICCAL: measuring audio (%lu ms)...\r\n", (unsigned long)MIC_CAL_MEASURE_MS);

    double audio_p = 0.0;
    uint32_t n_audio = 0u;
    st = mic_cal_measure_mean_power_started((uint32_t)MIC_CAL_MEASURE_MS, &audio_p, &n_audio, write);
    MIC_Stop();
    if (st != MIC_ERR_OK)
    {
        if (was_running) (void)MIC_Start();
        return st;
    }

    double signal_p = audio_p - quiet_p;
    if (signal_p < 0.0) signal_p = 0.0;

    if (signal_p <= 1e-12)
    {
        set_error(MIC_ERR_TIMEOUT, "ERROR: miccal audio not detected (signal <= noise)");
        if (write) write("ERR miccal audio not detected (signal <= noise)\r\n");
        if (was_running) (void)MIC_Start();
        return MIC_ERR_TIMEOUT;
    }

    float quiet_dbfs  = safe_dbfs_from_rms((float)sqrt(quiet_p));
    float audio_dbfs  = safe_dbfs_from_rms((float)sqrt(audio_p));
    float signal_dbfs = safe_dbfs_from_rms((float)sqrt(signal_p));

    float expected_dbfs = (float)MIC_CAL_SENS_DBFS_AT_94SPL + (spl_db - 94.0f);
    float offset_db = expected_dbfs - signal_dbfs;

    float gain = 1.0f, prev_off = 0.0f;
    MIC_CalGet(&gain, &prev_off);
    MIC_CalSet(gain, offset_db);
    uint8_t saved = MIC_CalSave();

    int32_t spl_x10 = (int32_t)(spl_db * 10.0f + ((spl_db >= 0.0f) ? 0.5f : -0.5f));
    int32_t exp_x100 = (int32_t)(expected_dbfs * 100.0f + ((expected_dbfs >= 0.0f) ? 0.5f : -0.5f));
    int32_t meas_x100 = (int32_t)(signal_dbfs * 100.0f + ((signal_dbfs >= 0.0f) ? 0.5f : -0.5f));
    int32_t off_x100 = exp_x100 - meas_x100;

    int32_t q_x100 = (int32_t)(quiet_dbfs * 100.0f + ((quiet_dbfs >= 0.0f) ? 0.5f : -0.5f));
    int32_t a_x100 = (int32_t)(audio_dbfs * 100.0f + ((audio_dbfs >= 0.0f) ? 0.5f : -0.5f));
    int32_t s_x100 = (int32_t)(signal_dbfs * 100.0f + ((signal_dbfs >= 0.0f) ? 0.5f : -0.5f));

    if (write)
    {
        mic_cal_writef(write, "MICCAL: mode=%s spl=%ld.%ld dB SPL @ mic\r\n",
                       mode_label ? mode_label : "?",
                       (long)(spl_x10 / 10), (long)(spl_x10 % 10));
        mic_cal_writef(write, "MICCAL: n_quiet=%lu n_audio=%lu\r\n",
                       (unsigned long)n_quiet, (unsigned long)n_audio);
        mic_cal_writef(write, "MICCAL: quiet=%ld audio=%ld signal=%ld (dBFS*100)\r\n",
                       (long)q_x100, (long)a_x100, (long)s_x100);
        mic_cal_writef(write, "MICCAL: expected=%ld meas=%ld offset_x100=%ld (%s)\r\n",
                       (long)exp_x100, (long)meas_x100, (long)off_x100,
                       saved ? "SAVED" : "NOT_SAVED");
        mic_cal_writef(write, "MICCAL: set in mic.h: #define MIC_CAL_DB_OFFSET_DB (%ld/100.0f)\r\n",
                       (long)off_x100);
        if (!saved)
            write("MICCAL: WARN: persistent save failed (RTC BKP not ready?)\r\n");
    }

    if (was_running)
        (void)MIC_Start();

    return MIC_ERR_OK;
}

mic_err_t MIC_CalibrateInteractiveAuto(mic_write_fn_t write,
                                      mic_wait_enter_fn_t wait_enter,
                                      mic_beep_fn_t beep)
{
    float spl_db = (float)MIC_CAL_AUTO_REF_SPL_DB;
    float ref_dist_cm = (float)MIC_CAL_AUTO_REF_DIST_CM;
    float mic_dist_cm = (float)MIC_CAL_AUTO_MIC_DIST_CM;
    if (ref_dist_cm > 0.0f && mic_dist_cm > 0.0f)
    {
        spl_db += 20.0f * log10f(ref_dist_cm / mic_dist_cm);
    }

    return mic_calibrate_interactive(spl_db, "auto", 1u, write, wait_enter, beep);
}

mic_err_t MIC_CalibrateInteractiveManualSpl(float spl_db,
                                            mic_write_fn_t write,
                                            mic_wait_enter_fn_t wait_enter)
{
    return mic_calibrate_interactive(spl_db, "manual", 0u, write, wait_enter, NULL);
}

/* Legacy API kept for CLI compatibility. */

float MIC_LastDbFS(void) { return s_last_dbfs; }
float MIC_LastRms(void)  { return s_last_rms; }
const char* MIC_LastErrorMsg(void) { return s_last_err_msg; }

float MIC_ReadDbFS(void)
{
    return MIC_ReadDbFS_Debug();
}

float MIC_ReadDbFS_Debug(void)
{
    /* One-shot read: enable debug, start, wait for first 50 ms window, then stop. */
    uint8_t prev_dbg = s_debug;
    s_debug = 1u;

    if (!s_inited)
        MIC_Init();

    mic_err_t e = MIC_Start();
    if (e != MIC_ERR_OK)
    {
        s_debug = prev_dbg;
        return -1.0f;
    }

    uint32_t t0 = HAL_GetTick();
    while (1)
    {
        MIC_Task();
        if (s_last_err == MIC_ERR_OK)
        {
            /* First window ready. */
            break;
        }

        if (s_last_err != MIC_ERR_NO_DATA_YET)
        {
            MIC_Stop();
            s_debug = prev_dbg;
            return -1.0f;
        }

        if ((HAL_GetTick() - t0) > 600u)
        {
            set_error(MIC_ERR_TIMEOUT, "ERROR: timeout waiting for 50ms window");
            MIC_Stop();
            s_debug = prev_dbg;
            return -1.0f;
        }
    }

    float out = s_last_dbfs;
    MIC_Stop();
    s_debug = prev_dbg;
    return out;
}

const char* MIC_ErrName(mic_err_t e)
{
    switch (e)
    {
        case MIC_ERR_OK: return "OK";
        case MIC_ERR_NOT_INIT: return "NOT_INIT";
        case MIC_ERR_SPI_NOT_READY: return "SPI_NOT_READY";
        case MIC_ERR_START_DMA: return "START_DMA";
        case MIC_ERR_TIMEOUT: return "TIMEOUT";
        case MIC_ERR_SPI_ERROR: return "SPI_ERROR";
        case MIC_ERR_DMA_NO_WRITE: return "DMA_NO_WRITE";
        case MIC_ERR_DATA_STUCK: return "DATA_STUCK";
        case MIC_ERR_SIGNAL_SATURATED: return "SIGNAL_SATURATED";
        case MIC_ERR_NO_DATA_YET: return "NO_DATA_YET";
        default: return "UNKNOWN";
    }
}

static mic_err_t mic_ensure_started(void)
{
    mic_err_t st = MIC_Start();
    if (st == MIC_ERR_NOT_INIT)
    {
        MIC_Init();
        st = MIC_Start();
    }
    return st;
}

mic_err_t MIC_ReadDbfsX100_Blocking(uint32_t timeout_ms, int16_t *out_dbfs_x100)
{
    if (out_dbfs_x100) *out_dbfs_x100 = 0;
    const uint8_t auto_stop = (mic_get_target_ms() != 0u) ? 1u : 0u;

    mic_err_t start = mic_ensure_started();
    if (start != MIC_ERR_OK)
        return start;

    float dbfs = 0.0f;
    float rms  = 0.0f;
    mic_err_t st = MIC_GetLast50ms(&dbfs, &rms);

    uint32_t t0 = HAL_GetTick();
    while ((st == MIC_ERR_NO_DATA_YET || st == MIC_ERR_DATA_STUCK) && ((HAL_GetTick() - t0) < timeout_ms))
    {
        MIC_Task();
        /* Do not enter sleep here; some low-power configs can stall SPI/DMA progress. */
        HAL_Delay(1);
        st = MIC_GetLast50ms(&dbfs, &rms);
    }

    if (st != MIC_ERR_OK)
    {
        if (st == MIC_ERR_NO_DATA_YET)
        {
            set_error(MIC_ERR_TIMEOUT, "ERROR: timeout waiting for 50ms window");
            micfft_invalidate(MIC_ERR_TIMEOUT);
            st = MIC_ERR_TIMEOUT;
        }
        if (auto_stop) MIC_Stop();
        return st;
    }

    if (out_dbfs_x100)
        *out_dbfs_x100 = mic_dbfs_to_x100_i16(dbfs);
    if (auto_stop) MIC_Stop();
    return MIC_ERR_OK;
}

mic_err_t MIC_FFT_GetLastBinsDbX100(int16_t *out_lf_db_x100,
                                   int16_t *out_mf_db_x100,
                                   int16_t *out_hf_db_x100)
{
    if (out_lf_db_x100) *out_lf_db_x100 = 0;
    if (out_mf_db_x100) *out_mf_db_x100 = 0;
    if (out_hf_db_x100) *out_hf_db_x100 = 0;

    /* If mic capture is in trouble, surface that first. */
    if (s_last_err != MIC_ERR_OK && s_last_err != MIC_ERR_NO_DATA_YET)
        return s_last_err;

    if (!s_fft_have_bins)
        return s_fft_last_err;

    if (out_lf_db_x100) *out_lf_db_x100 = s_fft_last_lf_db_x100;
    if (out_mf_db_x100) *out_mf_db_x100 = s_fft_last_mf_db_x100;
    if (out_hf_db_x100) *out_hf_db_x100 = s_fft_last_hf_db_x100;
    return MIC_ERR_OK;
}

mic_err_t MIC_FFT_WaitBinsDbX100(uint32_t timeout_ms,
                                int16_t *out_lf_db_x100,
                                int16_t *out_mf_db_x100,
                                int16_t *out_hf_db_x100)
{
    if (out_lf_db_x100) *out_lf_db_x100 = 0;
    if (out_mf_db_x100) *out_mf_db_x100 = 0;
    if (out_hf_db_x100) *out_hf_db_x100 = 0;
    const uint8_t auto_stop = (mic_get_target_ms() != 0u) ? 1u : 0u;

    mic_err_t start = mic_ensure_started();
    if (start != MIC_ERR_OK)
        return start;

    mic_err_t st = MIC_FFT_GetLastBinsDbX100(out_lf_db_x100, out_mf_db_x100, out_hf_db_x100);

    uint32_t t0 = HAL_GetTick();
    while ((st == MIC_ERR_NO_DATA_YET || st == MIC_ERR_DATA_STUCK) && ((HAL_GetTick() - t0) < timeout_ms))
    {
        MIC_Task();
        /* Do not enter sleep here; some low-power configs can stall SPI/DMA progress. */
        HAL_Delay(1);
        st = MIC_FFT_GetLastBinsDbX100(out_lf_db_x100, out_mf_db_x100, out_hf_db_x100);
    }

    if (st == MIC_ERR_NO_DATA_YET)
    {
        set_error(MIC_ERR_TIMEOUT, "ERROR: timeout waiting for micfft window");
        micfft_invalidate(MIC_ERR_TIMEOUT);
        st = MIC_ERR_TIMEOUT;
    }

    if (auto_stop) MIC_Stop();
    return st;
}

/* =====================================================================================
 * USB CLI helper: MICDIAG (debug)
 * ===================================================================================== */

static void micdiag_writef(mic_write_fn_t write, const char *fmt, ...)
{
    if (!write || !fmt) return;
    char buf[200];
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);
    write(buf);
}

void MIC_WriteDiag(mic_write_fn_t write)
{
    if (!write) return;

    uint32_t now = HAL_GetTick();

    mic_err_t last_err = s_last_err;
    const char *last_msg = s_last_err_msg;

    uint8_t inited   = s_inited;
    uint8_t running  = s_running;
    uint8_t interval = s_interval_active;
    uint8_t dma_circ = s_dma_circular;

    uint32_t spi_state = (uint32_t)HAL_SPI_GetState(&hspi1);
    uint32_t spi_err   = (uint32_t)hspi1.ErrorCode;

    uint32_t pclk = HAL_RCC_GetPCLK1Freq();
    if (pclk == 0u) pclk = HAL_RCC_GetHCLKFreq();
    uint32_t div  = mic_spi_prescaler_div(hspi1.Init.BaudRatePrescaler);
    uint32_t sck  = (div != 0u) ? (pclk / div) : 0u;
    uint32_t bits = mic_spi_bits_per_word();

    uint32_t cb_half = s_cb_half_count;
    uint32_t cb_full = s_cb_full_count;
    uint32_t cb_err  = s_cb_err_count;

    uint32_t dma_ccr = 0u;
    uint32_t dma_cndtr = 0u;
    if (hspi1.hdmarx && hspi1.hdmarx->Instance)
    {
        dma_ccr = hspi1.hdmarx->Instance->CCR;
        dma_cndtr = hspi1.hdmarx->Instance->CNDTR;
    }

    uint32_t last_evt_age = (s_dma_last_evt_ms != 0u) ? (now - s_dma_last_evt_ms) : 0xFFFFFFFFu;
    uint32_t last_rx_age  = (s_last_rx_ms != 0u) ? (now - s_last_rx_ms) : 0xFFFFFFFFu;

    uint32_t elapsed_ms = (s_cb_start_ms != 0u) ? (now - s_cb_start_ms) : 0u;
    uint32_t delta_full = cb_full - s_cb_full_start_count;
    uint64_t words_captured = (uint64_t)delta_full * (uint64_t)MIC_DMA_WORDS;
    uint32_t words_per_s = 0u;
    uint32_t sck_est_hz = 0u;
    if (elapsed_ms != 0u)
    {
        words_per_s = (uint32_t)((words_captured * 1000ull) / (uint64_t)elapsed_ms);
        sck_est_hz = words_per_s * bits;
    }

    micdiag_writef(write, "MICDIAG: inited=%u running=%u interval=%u dma_circ=%u spi_state=%lu spi_err=0x%08lX\r\n",
                   (unsigned)inited, (unsigned)running, (unsigned)interval, (unsigned)dma_circ,
                   (unsigned long)spi_state, (unsigned long)spi_err);
    micdiag_writef(write, "MICDIAG: last=%s(%ld) msg=%s\r\n",
                   MIC_ErrName(last_err), (long)last_err, last_msg ? last_msg : "");
    micdiag_writef(write, "MICDIAG: PCLK1=%luHz presc=%lu => SCK~%luHz bits=%lu decim=%u fs~%luHz\r\n",
                   (unsigned long)pclk, (unsigned long)div, (unsigned long)sck, (unsigned long)bits,
                   (unsigned)MIC_DECIM_N, (unsigned long)s_pcm_fs_hz);
    micdiag_writef(write, "MICDIAG: dma CCR=0x%08lX CNDTR=%lu last_evt_age=%lums cb_half=%lu cb_full=%lu cb_err=%lu sck_est~%luHz\r\n",
                   (unsigned long)dma_ccr, (unsigned long)dma_cndtr, (unsigned long)last_evt_age,
                   (unsigned long)cb_half, (unsigned long)cb_full, (unsigned long)cb_err,
                   (unsigned long)sck_est_hz);
    micdiag_writef(write, "MICDIAG: last_rx age=%lums words=%lu 0000=%lu ffff=%lu trans=%lu min=0x%04X max=0x%04X\r\n",
                   (unsigned long)last_rx_age,
                   (unsigned long)s_last_rx_words,
                   (unsigned long)s_last_rx_cnt_0000,
                   (unsigned long)s_last_rx_cnt_ffff,
                   (unsigned long)s_last_rx_transitions,
                   (unsigned)s_last_rx_minw,
                   (unsigned)s_last_rx_maxw);

    if (s_last_rx_first_n)
    {
        micdiag_writef(write, "MICDIAG: first:");
        for (uint32_t i = 0; i < s_last_rx_first_n; i++)
            micdiag_writef(write, " %04X", (unsigned)s_last_rx_first[i]);
        micdiag_writef(write, "\r\n");
    }
}

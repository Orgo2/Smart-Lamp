/*
 * mic.c - PDM microphone capture over SPI1 + DMA.
 * Provides a lightweight RMS/dBFS estimate over 50 ms windows (for simple VU-meter effects).
 */

#include "main.h"
#include "mic.h"
#include "stm32u0xx_hal.h"

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

/* SPI1 handle is generated by CubeMX in main.c. */
extern SPI_HandleTypeDef hspi1;

/* DSP config: decimation + 50 ms windows for RMS/dBFS measurement. */
#ifndef MIC_DECIM_N
#define MIC_DECIM_N  8u
#endif

/* RMS/dBFS integration window length. */
#define MIC_WINDOW_MS         50u

/* Samples per window at the expected post-decimation sample rate (approx). */
#define MIC_WINDOW_SAMPLES    313u

/* DMA strategy: repeated short RX transfers (start -> wait -> process -> restart). */
#define MIC_DMA_WORDS         512u
#define MIC_TIMEOUT_MS        200u

/* DMA RX buffer for one block. */
static uint16_t s_rx_buf[MIC_DMA_WORDS];

/* DMA transfer state. */
static volatile uint8_t s_spi_done;
static volatile uint8_t s_spi_err;
static uint32_t s_dma_t0_ms;
static uint32_t s_capture_t0_ms;

/* Driver state. */
static uint8_t s_inited;
static uint8_t s_running;
static uint8_t s_debug;
static mic_err_t s_last_err;
static const char *s_last_err_msg;

/* Last computed window result. */
static float s_last_dbfs = -1.0f;
static float s_last_rms  = 0.0f;

/* Accumulators for one 50 ms RMS/dBFS window. */
static uint32_t s_win_count;      /* number of PCM samples collected */
static double   s_win_sum_sq;     /* sum(sample^2) for RMS */
static double   s_win_peak;       /* peak amplitude (debug) */
static uint32_t s_decim_phase;    /* decimation phase counter */

/* Compile-time power-save settings (MIC_POWERSAVE in mic.h). */
static inline uint32_t mic_get_target_ms(void)
{
    /* 0 = continuous */
    if (MIC_POWERSAVE == 0u) return 0u;
    /* 1..10 = minimum 10ms */
    uint32_t target = (MIC_POWERSAVE <= 10u) ? 10u : (uint32_t)MIC_POWERSAVE;

    /* Ensure at least wake-up + one 50ms window worth of time. */
    uint32_t min_target = (uint32_t)MIC_WAKEUP_MS + (uint32_t)MIC_WINDOW_MS;
    if (target < min_target) target = min_target;
    return target;
}

/* last DMA snapshot for CLI dump */
static uint8_t  s_have_last_dma;
static uint32_t s_last_dma_words;

const uint16_t* MIC_DebugLastDmaBuf(uint32_t *out_words)
{
    if (out_words) *out_words = s_last_dma_words;
    return s_have_last_dma ? s_rx_buf : NULL;
}

/* Optional one-shot capture mode used for power-save measurements. */
static uint8_t  s_interval_active;
static uint32_t s_interval_t0_ms;

/* Debug logging helper. */
#define MIC_DBG(...) do { if (s_debug) printf(__VA_ARGS__); } while (0)

/* Error handling + dBFS conversion helpers. */
static float safe_dbfs_from_rms(float rms)
{
    /* Avoid log(0). */
    if (rms < 1e-6f) return -120.0f;
    return 20.0f * log10f(rms);
}

static void set_error(mic_err_t e, const char *msg)
{
    s_last_err = e;
    s_last_err_msg = msg;
    if (msg && s_debug)
        printf("[MIC] %s\r\n", msg);
}

/* PDM->PCM pipeline: CIC + decimation + short FIR smoothing (feeds RMS accumulator). */

/* CIC state (single channel). */
static int32_t s_cic_integrator;
static int32_t s_cic_comb_prev;

/* FIR moving average (simple low-pass). */
#define MIC_FIR_TAPS  8u
static int32_t s_fir_hist[MIC_FIR_TAPS];
static uint32_t s_fir_pos;

static void pdm2pcm_reset(void)
{
    s_cic_integrator = 0;
    s_cic_comb_prev  = 0;
    memset(s_fir_hist, 0, sizeof(s_fir_hist));
    s_fir_pos = 0u;
}

static inline uint8_t popcount16_inline(uint16_t x)
{
    uint8_t c = 0;
    while (x)
    {
        x &= (uint16_t)(x - 1u);
        c++;
    }
    return c;
}

/* Convert 16 PDM bits into a signed CIC input in range [-16..+16]. */
static inline int32_t pdm_word_to_cic_input(uint16_t w)
{
    int32_t ones = (int32_t)popcount16_inline(w);
    return (2 * ones) - 16;
}

static inline float pdm2pcm_step(int32_t cic_in)
{
    /* CIC integrator. */
    s_cic_integrator += cic_in;

    /* CIC comb */
    int32_t comb = s_cic_integrator - s_cic_comb_prev;
    s_cic_comb_prev = s_cic_integrator;

    /* FIR moving average */
    s_fir_hist[s_fir_pos] = comb;
    s_fir_pos = (s_fir_pos + 1u) % MIC_FIR_TAPS;

    int64_t acc = 0;
    for (uint32_t i = 0; i < MIC_FIR_TAPS; i++)
        acc += (int64_t)s_fir_hist[i];

    /* Normalize to roughly [-1..1] (not calibrated) and clamp for stability. */
    float y = (float)acc / (float)(MIC_FIR_TAPS * 256);
    if (y > 1.0f) y = 1.0f;
    if (y < -1.0f) y = -1.0f;
    return y;
}

/* HAL callbacks (DMA completion / error). */
void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi == &hspi1)
        s_spi_done = 1u;
}

void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
    if (hspi == &hspi1)
        s_spi_err = 1u;
}

/* Start one SPI RX DMA block (non-circular, processed in software). */
static mic_err_t start_dma_block(void)
{
    /* Fill with 0xAA so we can detect "DMA wrote nothing" cases. */
    memset(s_rx_buf, 0xAA, sizeof(s_rx_buf));

    s_have_last_dma = 0u;
    s_last_dma_words = MIC_DMA_WORDS;

    s_spi_done = 0u;
    s_spi_err  = 0u;

    /* Basic sanity checks before starting DMA. */
    if (hspi1.Instance != SPI1)
    {
        set_error(MIC_ERR_NOT_INIT, "ERROR: SPI1 not initialized (hspi1.Instance != SPI1)");
        return MIC_ERR_NOT_INIT;
    }

    if (HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY)
    {
        set_error(MIC_ERR_SPI_NOT_READY, "ERROR: SPI not READY (busy from other code?)");
        return MIC_ERR_SPI_NOT_READY;
    }

    /* Start RX DMA (count is in 16-bit elements with the current SPI/DMA config). */
    HAL_StatusTypeDef st = HAL_SPI_Receive_DMA(&hspi1, (uint8_t*)s_rx_buf, MIC_DMA_WORDS);
    if (st != HAL_OK)
    {
        set_error(MIC_ERR_START_DMA, "ERROR: HAL_SPI_Receive_DMA failed");
        if (s_debug)
            printf("[MIC] HAL st=%d state=%d err=0x%08lX\r\n", (int)st, (int)HAL_SPI_GetState(&hspi1), (unsigned long)hspi1.ErrorCode);
        return MIC_ERR_START_DMA;
    }

    /* For debug: BUSY means SPI is actively generating CLOCK on PA5. */
    s_dma_t0_ms = HAL_GetTick();
    MIC_DBG("[MIC] DMA started. SPI state=%d (2=BUSY => CLOCK on PA5)\r\n", (int)HAL_SPI_GetState(&hspi1));
    return MIC_ERR_OK;
}

/* Process one DMA block and update the 50 ms RMS/dBFS window. */
static mic_err_t process_block_and_update_window(void)
{
    /* Detect "DMA wrote nothing" by checking the 0xAAAA fill pattern. */
    uint32_t still_aa = 0;
    for (uint32_t i = 0; i < MIC_DMA_WORDS; i++)
        if (s_rx_buf[i] == 0xAAAAu) still_aa++;

    if (still_aa == MIC_DMA_WORDS)
    {
        set_error(MIC_ERR_DMA_NO_WRITE, "ERROR: DMA completed but buffer unchanged (0xAAAA) -> DMA not writing");
        return MIC_ERR_DMA_NO_WRITE;
    }

    /* Save last block for CLI debug dump. */
    s_have_last_dma = 1u;
    s_last_dma_words = MIC_DMA_WORDS;

    uint8_t in_warmup = 0u;
    if (MIC_WAKEUP_MS != 0u)
    {
        uint32_t elapsed = HAL_GetTick() - s_capture_t0_ms;
        if (elapsed < (uint32_t)MIC_WAKEUP_MS) in_warmup = 1u;
    }

    /* Quick data-quality check: detect stuck DATA (all 0x0000/0xFFFF) -> RMS ~= 1.0. */
    uint32_t bad_count = 0u;

    for (uint32_t i = 0; i < MIC_DMA_WORDS; i++)
    {
        uint16_t w = s_rx_buf[i];
        /* Count words that look stuck (all zeros/all ones). */
        if ((w == 0x0000u) || (w == 0xFFFFu)) bad_count++;
    }

    /* If all words are stuck (after warmup), abort with error. */
    if ((!in_warmup) && (bad_count == MIC_DMA_WORDS))
    {
        set_error(MIC_ERR_DATA_STUCK, "ERROR: PDM DATA stuck (all 0x0000 or 0xFFFF)");
        return MIC_ERR_DATA_STUCK;
    }

    /* PDM->PCM + decimation + RMS accumulator update. */
    for (uint32_t i = 0; i < MIC_DMA_WORDS; i++)
    {
        /* CIC input derived from 16 PDM bits. */
        int32_t cic_in = pdm_word_to_cic_input(s_rx_buf[i]);

        /* Keep only every N-th sample (but always advance CIC/FIR state). */
        if ((s_decim_phase++ % MIC_DECIM_N) != 0u)
        {
            /* Even dropped samples must advance CIC/FIR state. */
            (void)pdm2pcm_step(cic_in);
            continue;
        }

        float s = pdm2pcm_step(cic_in);

        if (in_warmup)
        {
            continue;
        }

        /* Accumulate RMS window. */
        double sd = (double)s;
        s_win_sum_sq += sd * sd;

        double a = (sd >= 0.0) ? sd : -sd;
        if (a > s_win_peak) s_win_peak = a;

        s_win_count++;

        /* When the window is full, finalize RMS/dBFS and store the result. */
        if (s_win_count >= MIC_WINDOW_SAMPLES)
        {
            float rms = (float)sqrt(s_win_sum_sq / (double)s_win_count);
            float dbfs = safe_dbfs_from_rms(rms);

            /* Guard against suspicious saturation (often wiring/clock/polarity issues). */
            if (rms > 0.98f || s_win_peak > 0.98)
            {
                MIC_DBG("[MIC] WARNING: saturation suspected: rms=%.4f peak=%.4f\r\n", (double)rms, (double)s_win_peak);
                set_error(MIC_ERR_SIGNAL_SATURATED, "ERROR: signal saturated (RMS/PEAK ~ 1.0) - likely DATA stuck or wrong clock/polarity");

                /* Reset window so we don't get stuck returning the same error forever. */
                s_win_count  = 0u;
                s_win_sum_sq = 0.0;
                s_win_peak   = 0.0;
                return MIC_ERR_SIGNAL_SATURATED;
            }

            s_last_rms  = rms;
            s_last_dbfs = dbfs;
            s_last_err  = MIC_ERR_OK;
            s_last_err_msg = NULL;

            MIC_DBG("[MIC] 50ms window ready: n=%lu rms=%.4f dbfs=%.2f peak=%.4f\r\n",
                    (unsigned long)s_win_count, (double)rms, (double)dbfs, (double)s_win_peak);

            /* Reset window for the next measurement. */
            s_win_count  = 0u;
            s_win_sum_sq = 0.0;
            s_win_peak   = 0.0;
        }
    }

    return MIC_ERR_OK;
}

/* =====================================================================================
 * PUBLIC API (driver)
 * ===================================================================================== */

void MIC_SetDebug(uint8_t enable)
{
    s_debug = (enable != 0u) ? 1u : 0u;
}

void MIC_Init(void)
{
    /* SPI/DMA are initialized by CubeMX; MIC_Init only resets driver state. */
    s_inited = 1u;
    s_running = 0u;
    s_last_err = MIC_ERR_NOT_INIT;
    s_last_err_msg = "not started";
    s_dma_t0_ms = 0u;
    s_capture_t0_ms = 0u;

    s_win_count  = 0u;
    s_win_sum_sq = 0.0;
    s_win_peak   = 0.0;
    s_decim_phase = 0u;

    s_last_dbfs = -120.0f;
    s_last_rms  = 0.0f;

    /* debug default off */
    /* Keep s_debug as set before init. */

    s_interval_active = 0u;
    s_interval_t0_ms  = 0u;
    s_have_last_dma   = 0u;
    s_last_dma_words  = MIC_DMA_WORDS;

    s_capture_t0_ms = s_dma_t0_ms;
    pdm2pcm_reset();

    MIC_DBG("[MIC] Init done. Window=%ums, samples=%u, decim=%u\r\n",
            (unsigned)MIC_WINDOW_MS, (unsigned)MIC_WINDOW_SAMPLES, (unsigned)MIC_DECIM_N);
}

mic_err_t MIC_Start(void)
{
    if (!s_inited)
    {
        set_error(MIC_ERR_NOT_INIT, "ERROR: MIC_Start called before MIC_Init");
        return MIC_ERR_NOT_INIT;
    }

    if (s_running)
        return MIC_ERR_OK;

    /* Start the first DMA block. */
    mic_err_t e = start_dma_block();
    if (e != MIC_ERR_OK)
        return e;

    /* Reset PDM->PCM state for each new measurement (continuous or one-shot). */
    pdm2pcm_reset();

    s_running = 1u;

    /* interval mode setup */
    if (mic_get_target_ms() != 0u)
    {
        s_interval_active = 1u;
        s_interval_t0_ms  = HAL_GetTick();

        /* Reset accumulators for one-shot interval measurement. */
        s_win_count  = 0u;
        s_win_sum_sq = 0.0;
        s_win_peak   = 0.0;
        s_decim_phase = 0u;

        /* Placeholder result until the first window completes. */
        s_last_rms  = 0.0f;
        s_last_dbfs = -120.0f;
        s_last_err  = MIC_ERR_NO_DATA_YET;
        s_last_err_msg = "no data yet";

        MIC_DBG("[MIC] PowerSave compile-time: capture %lu ms then stop\r\n", (unsigned long)mic_get_target_ms());
    }
    else
    {
        s_interval_active = 0u;
        s_last_err = MIC_ERR_NO_DATA_YET;
        s_last_err_msg = "no data yet";
    }

    return MIC_ERR_OK;
}

void MIC_Stop(void)
{
    if (!s_running)
    {
        s_interval_active = 0u;
        return;
    }

    (void)HAL_SPI_Abort(&hspi1);
    s_running = 0u;
    s_interval_active = 0u;
}

void MIC_Task(void)
{
    /* Periodic driver task: advances DMA capture and updates the 50 ms RMS window. */
    if (!s_inited)
        return;

    if (!s_running)
        return;

    /* Abort on SPI error. */
    if (s_spi_err)
    {
        set_error(MIC_ERR_SPI_ERROR, "ERROR: SPI error during capture");
        MIC_Stop();
        return;
    }

    /* If DMA is not done yet, only check for timeout. */
    if (!s_spi_done)
    {
        if ((HAL_GetTick() - s_dma_t0_ms) > MIC_TIMEOUT_MS)
        {
            set_error(MIC_ERR_TIMEOUT, "ERROR: DMA timeout waiting for RxCplt");
            MIC_Stop();
        }
        return;
    }

    /* DMA complete: process the received block. */
    (void)process_block_and_update_window();

    /*
     * Interval mode: keep restarting DMA until the target capture time elapses,
     * then compute RMS and stop.
     */
    if (s_interval_active)
    {
        uint32_t elapsed = HAL_GetTick() - s_interval_t0_ms;
        uint32_t target  = mic_get_target_ms();

        if (elapsed < target)
        {
            (void)start_dma_block();
            return;
        }
        /* Interval finished: do not start another DMA block. */
    }

    /* Continuous mode: always restart DMA. */
    if (mic_get_target_ms() == 0u)
    {
        (void)start_dma_block();
        return;
    }

    /* ===== interval-finish (elapsed>=target) ===== */
    if (s_interval_active)
    {
        uint32_t elapsed = HAL_GetTick() - s_interval_t0_ms;
        uint32_t target  = mic_get_target_ms();

        if (elapsed >= target)
        {
            if (s_win_count == 0u)
            {
                set_error(MIC_ERR_TIMEOUT, "ERROR: interval finished but no samples collected");
                MIC_Stop();
                s_interval_active = 0u;
                return;
            }

            float rms = (float)sqrt(s_win_sum_sq / (double)s_win_count);
            float dbfs = safe_dbfs_from_rms(rms);

            if (rms > 0.98f || s_win_peak > 0.98)
            {
                set_error(MIC_ERR_SIGNAL_SATURATED, "ERROR: signal saturated (interval RMS/PEAK ~ 1.0)");
                MIC_Stop();
                s_interval_active = 0u;
                return;
            }

            s_last_rms  = rms;
            s_last_dbfs = dbfs;
            s_last_err  = MIC_ERR_OK;
            s_last_err_msg = NULL;

            MIC_DBG("[MIC] Interval %lums done: n=%lu rms=%.4f dbfs=%.2f\r\n",
                    (unsigned long)target,
                    (unsigned long)s_win_count,
                    (double)rms,
                    (double)dbfs);

            MIC_Stop();
            s_interval_active = 0u;
            return;
        }
    }
}

mic_err_t MIC_GetLast50ms(float *out_dbfs, float *out_rms)
{
    /* In interval mode, auto-start capture on first read. */
    if (s_inited && (mic_get_target_ms() != 0u) && (!s_running) && (!s_interval_active))
    {
        (void)MIC_Start();
    }

    if (out_dbfs) *out_dbfs = (s_last_err == MIC_ERR_OK) ? s_last_dbfs : 0.0f;
    if (out_rms)  *out_rms  = (s_last_err == MIC_ERR_OK) ? s_last_rms  : 0.0f;
    return s_last_err;
}

/* Legacy API kept for CLI compatibility. */

float MIC_LastDbFS(void) { return s_last_dbfs; }
float MIC_LastRms(void)  { return s_last_rms; }
const char* MIC_LastErrorMsg(void) { return s_last_err_msg; }

float MIC_ReadDbFS(void)
{
    return MIC_ReadDbFS_Debug();
}

float MIC_ReadDbFS_Debug(void)
{
    /* One-shot read: enable debug, start, wait for first 50 ms window, then stop. */
    uint8_t prev_dbg = s_debug;
    s_debug = 1u;

    if (!s_inited)
        MIC_Init();

    mic_err_t e = MIC_Start();
    if (e != MIC_ERR_OK)
    {
        s_debug = prev_dbg;
        return -1.0f;
    }

    uint32_t t0 = HAL_GetTick();
    while (1)
    {
        MIC_Task();
        if (s_last_err == MIC_ERR_OK)
        {
            /* First window ready. */
            break;
        }

        if (s_last_err != MIC_ERR_NO_DATA_YET)
        {
            MIC_Stop();
            s_debug = prev_dbg;
            return -1.0f;
        }

        if ((HAL_GetTick() - t0) > 600u)
        {
            set_error(MIC_ERR_TIMEOUT, "ERROR: timeout waiting for 50ms window");
            MIC_Stop();
            s_debug = prev_dbg;
            return -1.0f;
        }
    }

    float out = s_last_dbfs;
    MIC_Stop();
    s_debug = prev_dbg;
    return out;
}
